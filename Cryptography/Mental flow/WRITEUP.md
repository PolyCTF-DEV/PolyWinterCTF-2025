
# Mental flow | hard | crypto

## Информация
> Поток гениальных мыслей захлестнул меня, да так, что я реализовал этот гениальный шифр с нелинейным прямым распадом. Расшифруй, докажи что ты тоже гениален.

## Выдать участникам
файлы [cipher.py](public/cipher.py), [encoder.py](public/encoder.py) и [output.txt](public/output.txt)

## Описание
Перед нами классическая схема потокового шифра, где keystream генерируется с помошью LFSR (Регистр сдвига с линейной обратной связью)

## Решение
В первую очередь смотрим на основной файл шифроваиня encoder.py. В нем на вход ожидаются некоторые секретные числа, которые конвертируются в список, который называется **полином**. Затем это значение передается в конструктор некоторого шифра, который в свою очередь шифрует флаг. Результат этого шифрования находится в output.txt.

**Ананлиз cipher.py**
В конструкторе видим, что экземпляр шифра, кроме полинома, ожидает еще и сид, который в нашем случае генерируется случайно как последовательность 32х бит.
Метод `encrypt()` представляет собой обычный потоковый шифр: входной текст ксорится с ключом такого же размера. В этой схеме под ключом подразумевается keystream, который генерируется с помошью метода `step`. 

Для расшифровки флага, необходимо восстановить поток ключей. 
Исходя из:
- шифр с нелинейным прямым распадом (из описания)
- аргумент класса шифра называется polynom
- Код метода `step`

Можно легко догадаться, что здесь используется LFSR. Не буду углублятся в то что это такое и как он работает, главное понимать, что он состоит из двух глучевых вещей: состояния регистра (`state` в нашем случае) и полинома, который задает новый выходной бит. Зная их, можно легко восстановить поток ключей. начальнео состояние регистра нам дано, кроме этого, мы можем восстановить первые 64 бита потока ключей, т.к. первые 8 байт флага у нас фиксированы (ксор между `PolyCTF{` и первыйми байтами шифротекста).

Осталось восстановить полином.Сарзу можно сказать, что полным перебором задача будет решаться долго, т.к. максимальная степень полинома 32 и длина его может быть от 1 до 32 (сумма сочетаний из 32х по k, где k от 1 до 32, немало). На этом этапе можно начать гуглить что то вроде `recover LFSR` и рано или поздно дойти до алгоритма Берлекэмпа-Мэсси, который помжет помочь в восстановлении полинома при некоторой известной длине исходного текста. Порыскав на гитхабе (не много, по поиску lfsr recover, репозиторий 10й примерно) можно найти код его реализации (в сам алгоритм я тоже подробно углублся в райтапе не буду). Взяв его за основу,полчится такой код восстановления полинома:

```python
        n = len(sequence)
        C = [0] * n
        B = [0] * n
        C[0] = 1
        B[0] = 1
        L, m, b = 0, -1, 1

        for i in range(n):
            d = sequence[i]
            for j in range(1, L + 1):
                d ^= C[j] & sequence[i - j]
            
            if d == 1:
                T = C[:]
                for j in range(n - i + m):
                    C[i - m + j] ^= B[j]
                if 2 * L <= i:
                    L = i + 1 - L
                    B = T
                    m = i
                    b = d

        self.polynomial = [i for i, x in enumerate(C) if x == 1]
        self.degree = L
```

где sequence на входе - это восстановленная часть потока ключей.

Алгоритм отрабатывает достаточно быстро, а после восстановления полинома задача тривальная: воспользоваться кодом шифратора, задава seed и polynom.

## Флаг
`PolyCTF{LFSR_1s_N0T_S3cure_B3rl3k4mp_M4ssey_Rev3als_K3ystr3am_And_Bre4ks_3ncryption}`
