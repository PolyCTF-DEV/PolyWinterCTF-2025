# Булевый предсказатель | medium | crypto

## Информация
> Этот нострадамус явно знает больше, чем вы, однако на любой вопрос он способен говорить только да или нет.

## Выдать участникам
файл сервера [server.py](public/server.py)

## Описание
стандартная уязвимость атака Parity oracle attack

## Решение
В исходном коде видим два эндпоинта:
- `public_key` - отдает значения публичного ключа и зашифрованного флага
- `oracle` - возвращает true или false в зависимости, четный ли текст, расшифрованный из переданныз данных.

Идея решения не сложная: с помощью оракула четности, классическим бинарным поиском найти M.

Знаем, что 0 < M <= N, берем ти значения в качетсве границ:

lower_bound = 0, upper_bound = n. 

Далее на каждой итерации передаем серверу C' = (C * 2^e) mod N, чтобы получить M' = 2*M, т.к.:

При расшифровке (C * 2^e)^d mod N -> (C^d * 2^(d * e)) mod N -> (M * 2) mod N, потому что e * d ≡ 1 mod N -> 2^e*d ≡ 2 mod N.

Далее, если M' четно, то его можно представить как (M' = 2 * M), значит реальное значени M будетв первой половине диапазона (0;N]. Если же M' нечетно, то его можно представить как (M' = 2 * M + N), значит реальное значние M будет во второй половине диапазона. После этого соотвествующим образом обновляем lower_bound и upper_bound. 

P.s. Замечу, что исзодя из слоножности бинарного поиска и размерности молуля N (2048 бит), максимальное число итераций для поиска сообщения - 2048, что достаточно мало.

## Флаг
`PolyCTF{p4r1ty_1s_fun_but_2s_c0mpl41nt}`
