# woow | easy | crypto

## Информация
> Что-то зашифровано. Что-то нужно расшифровать. Наверное. Или нет. Разберись сам.

## Выдать участникам
файлы [enc.py](public/enc.py) и [output.txt](public/output.txt)

## Описание
xor одним символом всего текста

## Решение
Задача заключалась в том, что текст и ключ имеют одинаковую длину после определенного преобразования:
```python
len(text*len(key)) == len(key*len(text))
```

Известно, что длина зашифрованного текста составляет 988 символов, а длина ключа находится в диапазоне от 12 до 44 символов. После расчетов выяснилось, что возможные длины ключа — 13, 19 или 26 символов, а длина исходного текста соответственно 76, 52 или 38 символов.

Давайте теперь попробуем разобрать какой-нибудь пример со своим текстом и ключом:

```
ТЕКСТ: polyctf_dog (11 символов)

КЛЮЧ: youtube (7 символов)
```


При преобразовании получаем одинаковую длину ключа и текста (77 символов):

```
polyctf_dogpolyctf_dogpolyctf_dogpolyctf_dogpolyctf_dogpolyctf_dogpolyctf_dog
youtubeyoutubeyoutubeyoutubeyoutubeyoutubeyoutubeyoutubeyoutubeyoutubeyoutube
```

В этом тексте можно заметить: что у ключа первый символ ксорит каждую букву с тексте:

```
polyctf_dogpolyctf_dogpolyctf_dogpolyctf_dogpolyctf_dogpolyctf_dogpolyctf_dog
y      y      y      y      y      y      y      y      y      y      y      
```

Если вытащить каждую букву:

```
p _ y g f l o t o d c
```

Осталось только собрать из этих букв наш текст.

Получается мы имеем готовый текст, который заксорен одним символом от 00 до FF, остается только подобрать.

При подборе находим строчку в base64:
```
UG9seUNURnt3MFdfN2gxc18xc19YMFJfNnJ1NzNfTG8wbkdzfQ==
```

Дешефруем и получаем флаг.

Прикладываю скрипт с решением [dec.py](solve/dec.py).

## Флаг
`PolyCTF{w0W_7h1s_1s_X0R_6ru73_Lo0nGs}`